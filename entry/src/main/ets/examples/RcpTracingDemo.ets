/**
 * RCP è¯·æ±‚è¿½è¸ªæ¼”ç¤º
 * 
 * æœ¬ç¤ºä¾‹æ¼”ç¤ºå¦‚ä½•ä½¿ç”¨ TracingConfiguration å’Œ HttpEventsHandler 
 * æ•è·HTTPè¯·æ±‚/å“åº”çš„è¯¦ç»†ä¿¡æ¯å’Œæ€§èƒ½æ•°æ®
 */

import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { RcpService } from '../services/RcpService';

const TAG = 'RcpTracingDemo';
const DOMAIN = 0xFF00;

/**
 * è¿½è¸ªä¿¡æ¯æ”¶é›†å™¨
 */
export class TracingInfoCollector {
  private dataReceiveCount: number = 0;
  private totalBytesReceived: number = 0;
  private headers: Record<string, string> = {};
  private events: string[] = [];

  reset(): void {
    this.dataReceiveCount = 0;
    this.totalBytesReceived = 0;
    this.headers = {};
    this.events = [];
  }

  recordDataReceive(bytes: number): void {
    this.dataReceiveCount++;
    this.totalBytesReceived += bytes;
    this.events.push(`[${new Date().toISOString()}] æ”¶åˆ°æ•°æ®: ${bytes} bytes`);
  }

  recordHeaderReceive(headers: rcp.RequestHeaders): void {
    this.headers = headers as Record<string, string>;
    this.events.push(`[${new Date().toISOString()}] æ”¶åˆ°å“åº”å¤´`);
  }

  recordDataEnd(): void {
    this.events.push(`[${new Date().toISOString()}] æ•°æ®ä¼ è¾“å®Œæˆ`);
  }

  getReport(): string {
    let report = '========== è¿½è¸ªæŠ¥å‘Š ==========\n\n';
    report += `æ•°æ®æ¥æ”¶æ¬¡æ•°: ${this.dataReceiveCount}\n`;
    report += `æ€»å­—èŠ‚æ•°: ${this.totalBytesReceived} bytes\n\n`;
    report += `å“åº”å¤´ (${Object.keys(this.headers).length}ä¸ª):\n`;
    for (const key in this.headers) {
      report += `  ${key}: ${this.headers[key]}\n`;
    }
    report += `\näº‹ä»¶æ—¶é—´çº¿:\n`;
    this.events.forEach(event => {
      report += `  ${event}\n`;
    });
    return report;
  }
}

/**
 * åˆ›å»ºè‡ªå®šä¹‰ HttpEventsHandler
 */
export function createCustomHttpEventsHandler(
  collector: TracingInfoCollector
): rcp.HttpEventsHandler {
  return {
    onDataReceive: (incomingData: ArrayBuffer) => {
      const bytes = incomingData.byteLength;
      collector.recordDataReceive(bytes);
      hilog.info(DOMAIN, TAG, `[HttpEventsHandler] æ”¶åˆ°æ•°æ®: ${bytes} bytes`);
      return bytes;
    },
    onHeaderReceive: (headers: rcp.RequestHeaders) => {
      collector.recordHeaderReceive(headers);
      hilog.info(DOMAIN, TAG, `[HttpEventsHandler] æ”¶åˆ°å“åº”å¤´: ${JSON.stringify(headers)}`);
    },
    onDataEnd: () => {
      collector.recordDataEnd();
      hilog.info(DOMAIN, TAG, '[HttpEventsHandler] æ•°æ®ä¼ è¾“å®Œæˆ');
    }
  };
}

/**
 * æ¼”ç¤º1: åŸºç¡€è¿½è¸ªåŠŸèƒ½
 */
export async function demo1_BasicTracing(): Promise<string> {
  hilog.info(DOMAIN, TAG, '========== æ¼”ç¤º1: åŸºç¡€è¿½è¸ªåŠŸèƒ½ ==========');

  const collector = new TracingInfoCollector();
  const customHandler = createCustomHttpEventsHandler(collector);

  // åˆ›å»ºè¿½è¸ªé…ç½®
  const tracingConfig: rcp.TracingConfiguration = {
    verbose: true,
    infoToCollect: {
      incomingHeader: true,
      outgoingHeader: true,
      incomingData: true,
      outgoingData: true
    },
    collectTimeInfo: true,
    httpEventsHandler: customHandler
  };

  const rcpService = RcpService.getInstance();
  const session = rcpService.createSessionWithTracing(tracingConfig);

  try {
    const response = await session.get('http://developer.huawei.com');

    let report = 'âœ… è¯·æ±‚æˆåŠŸ\n\n';
    report += `çŠ¶æ€ç : ${response.statusCode}\n\n`;
    report += RcpService.parseTimeInfo(response) + '\n\n';
    report += collector.getReport();

    return report;
  } catch (error) {
    const err = error as BusinessError;
    return `âŒ è¯·æ±‚å¤±è´¥: ${err.message}`;
  }
}

/**
 * æ¼”ç¤º2: æ€§èƒ½å¯¹æ¯”ï¼ˆæ— è¿½è¸ª vs æœ‰è¿½è¸ªï¼‰
 */
export async function demo2_PerformanceComparison(): Promise<string> {
  hilog.info(DOMAIN, TAG, '========== æ¼”ç¤º2: æ€§èƒ½å¯¹æ¯” ==========');

  const url = 'http://developer.huawei.com';
  let report = '';

  // 1. æ— è¿½è¸ªè¯·æ±‚
  const normalSession = rcp.createSession({
    requestConfiguration: {
      security: {
        tlsOptions: {
          tlsVersion: 'TlsV1.3'
        }
      }
    }
  });

  const startTime1 = Date.now();
  try {
    await normalSession.get(url);
    const duration1 = Date.now() - startTime1;
    report += `ğŸ“Š æ— è¿½è¸ªæ¨¡å¼:\n  è€—æ—¶: ${duration1}ms\n\n`;
  } catch (error) {
    report += 'âŒ æ— è¿½è¸ªæ¨¡å¼å¤±è´¥\n\n';
  }

  // 2. æœ‰è¿½è¸ªè¯·æ±‚
  const collector = new TracingInfoCollector();
  const tracingConfig = RcpService.createDefaultTracingConfig(
    createCustomHttpEventsHandler(collector)
  );

  const rcpService = RcpService.getInstance();
  const tracingSession = rcpService.createSessionWithTracing(tracingConfig);

  const startTime2 = Date.now();
  try {
    const response = await tracingSession.get(url);
    const duration2 = Date.now() - startTime2;

    report += `ğŸ“Š è¿½è¸ªæ¨¡å¼:\n  è€—æ—¶: ${duration2}ms\n\n`;
    report += `æ€§èƒ½å½±å“: ${((duration2 - startTime1) / startTime1 * 100).toFixed(2)}%\n\n`;
    report += RcpService.parseTimeInfo(response);
  } catch (error) {
    report += 'âŒ è¿½è¸ªæ¨¡å¼å¤±è´¥\n';
  }

  return report;
}

/**
 * æ¼”ç¤º3: è¯¦ç»†æ—¶é—´åˆ†æ
 */
export async function demo3_DetailedTimeAnalysis(): Promise<string> {
  hilog.info(DOMAIN, TAG, '========== æ¼”ç¤º3: è¯¦ç»†æ—¶é—´åˆ†æ ==========');

  const tracingConfig = RcpService.createDefaultTracingConfig();
  const rcpService = RcpService.getInstance();
  const session = rcpService.createSessionWithTracing(tracingConfig);

  try {
    const response = await session.get('https://developer.huawei.com');

    let report = 'âœ… è¯·æ±‚æˆåŠŸ\n\n';
    report += 'â±ï¸ æ—¶é—´åˆ†æ:\n';

    if (response.timeInfo) {
      const timeInfo = response.timeInfo;
      
      // DNSè§£æ
      if (timeInfo.dnsLookupTime !== undefined) {
        report += `  DNSè§£æ: ${timeInfo.dnsLookupTime}ms\n`;
      }
      
      // TCPè¿æ¥
      if (timeInfo.tcpConnectionTime !== undefined) {
        report += `  TCPè¿æ¥: ${timeInfo.tcpConnectionTime}ms\n`;
      }
      
      // TLSæ¡æ‰‹
      if (timeInfo.tlsConnectionTime !== undefined) {
        report += `  TLSæ¡æ‰‹: ${timeInfo.tlsConnectionTime}ms\n`;
      }
      
      // é¦–æ¬¡å‘é€
      if (timeInfo.firstSendTime !== undefined) {
        report += `  é¦–æ¬¡å‘é€: ${timeInfo.firstSendTime}ms\n`;
      }
      
      // é¦–æ¬¡æ¥æ”¶
      if (timeInfo.firstReceiveTime !== undefined) {
        report += `  é¦–æ¬¡æ¥æ”¶: ${timeInfo.firstReceiveTime}ms\n`;
      }
      
      // æ€»è€—æ—¶
      if (timeInfo.totalTime !== undefined) {
        report += `  æ€»è€—æ—¶: ${timeInfo.totalTime}ms\n\n`;
        
        // è®¡ç®—å„é˜¶æ®µå æ¯”
        const total = timeInfo.totalTime;
        if (timeInfo.dnsLookupTime) {
          report += `  DNSå æ¯”: ${(timeInfo.dnsLookupTime / total * 100).toFixed(2)}%\n`;
        }
        if (timeInfo.tcpConnectionTime) {
          report += `  TCPå æ¯”: ${(timeInfo.tcpConnectionTime / total * 100).toFixed(2)}%\n`;
        }
        if (timeInfo.tlsConnectionTime) {
          report += `  TLSå æ¯”: ${(timeInfo.tlsConnectionTime / total * 100).toFixed(2)}%\n`;
        }
      }
    } else {
      report += '  âš ï¸ æ— æ—¶é—´ä¿¡æ¯\n';
    }

    return report;
  } catch (error) {
    const err = error as BusinessError;
    return `âŒ è¯·æ±‚å¤±è´¥: ${err.message}`;
  }
}

/**
 * æ¼”ç¤º4: å¤šä¸ªè¯·æ±‚çš„è¿½è¸ªå¯¹æ¯”
 */
export async function demo4_MultipleRequestsComparison(): Promise<string> {
  hilog.info(DOMAIN, TAG, '========== æ¼”ç¤º4: å¤šä¸ªè¯·æ±‚è¿½è¸ªå¯¹æ¯” ==========');

  const urls = [
    'http://developer.huawei.com',
    'http://www.example.com',
    'https://api.github.com'
  ];

  const tracingConfig = RcpService.createDefaultTracingConfig();
  const rcpService = RcpService.getInstance();
  const session = rcpService.createSessionWithTracing(tracingConfig);

  let report = 'ğŸ“Š å¤šè¯·æ±‚æ€§èƒ½å¯¹æ¯”\n\n';

  for (let i = 0; i < urls.length; i++) {
    const url = urls[i];
    report += `è¯·æ±‚ ${i + 1}: ${url}\n`;

    try {
      const startTime = Date.now();
      const response = await session.get(url);
      const duration = Date.now() - startTime;

      report += `  çŠ¶æ€: âœ… æˆåŠŸ (${response.statusCode})\n`;
      report += `  æ€»è€—æ—¶: ${duration}ms\n`;

      if (response.timeInfo?.totalTime) {
        report += `  RCPæµ‹é‡: ${response.timeInfo.totalTime}ms\n`;
        report += `  DNS: ${response.timeInfo.dnsLookupTime || 0}ms\n`;
        report += `  TCP: ${response.timeInfo.tcpConnectionTime || 0}ms\n`;
        report += `  TLS: ${response.timeInfo.tlsConnectionTime || 0}ms\n`;
      }
    } catch (error) {
      const err = error as BusinessError;
      report += `  çŠ¶æ€: âŒ å¤±è´¥ (${err.message})\n`;
    }

    report += '\n';
  }

  return report;
}

/**
 * è¿è¡Œæ‰€æœ‰æ¼”ç¤º
 */
export async function runAllTracingDemos(): Promise<string> {
  let fullReport = '========== RCP è¿½è¸ªåŠŸèƒ½å®Œæ•´æ¼”ç¤º ==========\n\n';

  // æ¼”ç¤º1
  fullReport += await demo1_BasicTracing();
  fullReport += '\n\n';

  // å»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 1000));

  // æ¼”ç¤º2
  fullReport += await demo2_PerformanceComparison();
  fullReport += '\n\n';

  // å»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 1000));

  // æ¼”ç¤º3
  fullReport += await demo3_DetailedTimeAnalysis();
  fullReport += '\n\n';

  // å»¶è¿Ÿ
  await new Promise(resolve => setTimeout(resolve, 1000));

  // æ¼”ç¤º4
  fullReport += await demo4_MultipleRequestsComparison();

  fullReport += '\n========== æ¼”ç¤ºå®Œæˆ ==========';

  return fullReport;
}
