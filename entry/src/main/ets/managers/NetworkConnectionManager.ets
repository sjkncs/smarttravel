import { connection } from '@kit.NetworkKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { NetworkService, NetworkInfo, NetworkConnectivity, NetworkType } from '../services/NetworkService';

const TAG = 'NetworkConnectionManager';
const DOMAIN = 0xFF00;

/**
 * ç½‘ç»œçŠ¶æ€å˜åŒ–å›è°ƒ
 */
export type NetworkChangeCallback = (info: NetworkInfo) => void;

/**
 * ç½‘ç»œè¿æ¥ç®¡ç†å™¨
 * è´Ÿè´£ç›‘å¬é»˜è®¤ç½‘ç»œå˜åŒ–ã€ç®¡ç†ç½‘ç»œçŠ¶æ€è®¢é˜…
 */
export class NetworkConnectionManager {
  private static instance: NetworkConnectionManager;
  private netConnection: connection.NetConnection | null = null;
  private networkService: NetworkService;
  private changeCallbacks: Set<NetworkChangeCallback> = new Set();
  private currentNetworkInfo: NetworkInfo | null = null;
  private isListening: boolean = false;

  private constructor() {
    this.networkService = NetworkService.getInstance();
  }

  /**
   * è·å–å•ä¾‹å®ä¾‹
   */
  public static getInstance(): NetworkConnectionManager {
    if (!NetworkConnectionManager.instance) {
      NetworkConnectionManager.instance = new NetworkConnectionManager();
    }
    return NetworkConnectionManager.instance;
  }

  /**
   * å¼€å§‹ç›‘å¬é»˜è®¤ç½‘ç»œå˜åŒ–
   */
  public startListening(): void {
    if (this.isListening) {
      hilog.warn(DOMAIN, TAG, 'Already listening to network changes');
      return;
    }

    try {
      // åˆ›å»ºé»˜è®¤ç½‘ç»œè¿æ¥å¯¹è±¡
      this.netConnection = connection.createNetConnection();

      // ç›‘å¬ç½‘ç»œå¯ç”¨äº‹ä»¶
      this.netConnection.on('netAvailable', (netHandle: connection.NetHandle) => {
        hilog.info(DOMAIN, TAG, `Network available: ${netHandle.netId}`);
        this.handleNetworkChange(netHandle);
      });

      // ç›‘å¬ç½‘ç»œèƒ½åŠ›å˜åŒ–äº‹ä»¶
      this.netConnection.on('netCapabilitiesChange', (data: connection.NetCapabilityInfo) => {
        hilog.info(DOMAIN, TAG, `Network capabilities changed`);
        // ç›´æ¥è°ƒç”¨æ›´æ–°ï¼Œä¸éœ€è¦ netHandle
        this.updateCurrentNetworkInfo();
      });

      // ç›‘å¬ç½‘ç»œä¸å¯ç”¨äº‹ä»¶
      this.netConnection.on('netUnavailable', () => {
        hilog.warn(DOMAIN, TAG, 'Network unavailable');
        this.handleNetworkUnavailable();
      });

      // ç›‘å¬ç½‘ç»œä¸¢å¤±äº‹ä»¶
      this.netConnection.on('netLost', (netHandle: connection.NetHandle) => {
        hilog.warn(DOMAIN, TAG, `Network lost: ${netHandle.netId}`);
        this.handleNetworkLost(netHandle);
      });

      // æ³¨å†Œç›‘å¬
      this.netConnection.register((err: BusinessError) => {
        if (err) {
          hilog.error(DOMAIN, TAG, `Failed to register network listener: ${JSON.stringify(err)}`);
          this.isListening = false;
        } else {
          hilog.info(DOMAIN, TAG, 'Network listener registered successfully');
          this.isListening = true;
          // ç«‹å³è·å–å½“å‰ç½‘ç»œä¿¡æ¯
          this.updateCurrentNetworkInfo();
        }
      });
    } catch (err) {
      hilog.error(DOMAIN, TAG, `Failed to start listening: ${JSON.stringify(err)}`);
      this.isListening = false;
    }
  }

  /**
   * åœæ­¢ç›‘å¬ç½‘ç»œå˜åŒ–
   */
  public stopListening(): void {
    if (!this.isListening || !this.netConnection) {
      return;
    }

    try {
      // å–æ¶ˆæ³¨å†Œ
      this.netConnection.unregister((err: BusinessError) => {
        if (err) {
          hilog.error(DOMAIN, TAG, `Failed to unregister: ${JSON.stringify(err)}`);
        } else {
          hilog.info(DOMAIN, TAG, 'Network listener unregistered successfully');
        }
      });

      this.netConnection = null;
      this.isListening = false;
    } catch (err) {
      hilog.error(DOMAIN, TAG, `Failed to stop listening: ${JSON.stringify(err)}`);
    }
  }

  /**
   * è®¢é˜…ç½‘ç»œå˜åŒ–é€šçŸ¥
   */
  public subscribe(callback: NetworkChangeCallback): void {
    this.changeCallbacks.add(callback);
    hilog.info(DOMAIN, TAG, `Subscribed, total callbacks: ${this.changeCallbacks.size}`);

    // å¦‚æœå½“å‰æœ‰ç½‘ç»œä¿¡æ¯ï¼Œç«‹å³é€šçŸ¥
    if (this.currentNetworkInfo) {
      callback(this.currentNetworkInfo);
    }
  }

  /**
   * å–æ¶ˆè®¢é˜…ç½‘ç»œå˜åŒ–é€šçŸ¥
   */
  public unsubscribe(callback: NetworkChangeCallback): void {
    this.changeCallbacks.delete(callback);
    hilog.info(DOMAIN, TAG, `Unsubscribed, remaining callbacks: ${this.changeCallbacks.size}`);
  }

  /**
   * è·å–å½“å‰ç½‘ç»œä¿¡æ¯
   */
  public getCurrentNetworkInfo(): NetworkInfo | null {
    return this.currentNetworkInfo;
  }

  /**
   * æ‰‹åŠ¨åˆ·æ–°å½“å‰ç½‘ç»œä¿¡æ¯
   */
  public refreshNetworkInfo(): void {
    this.updateCurrentNetworkInfo();
  }

  /**
   * å¤„ç†ç½‘ç»œå˜åŒ–
   */
  private async handleNetworkChange(netHandle: connection.NetHandle): Promise<void> {
    try {
      const caps = await connection.getNetCapabilities(netHandle);
      const type = this.parseNetworkType(caps.bearerTypes);
      const connectivity = this.parseConnectivity(caps.networkCap);
      const isMetered = !caps.networkCap?.includes(connection.NetCap.NET_CAPABILITY_NOT_METERED);

      const newInfo: NetworkInfo = {
        netId: netHandle.netId,
        type,
        connectivity,
        isMetered
      };

      // æ£€æŸ¥æ˜¯å¦æœ‰å®è´¨æ€§å˜åŒ–
      if (this.hasNetworkInfoChanged(newInfo)) {
        hilog.info(DOMAIN, TAG, `Network changed: ${JSON.stringify(newInfo)}`);
        this.currentNetworkInfo = newInfo;
        this.notifyCallbacks(newInfo);
      }
    } catch (err) {
      hilog.error(DOMAIN, TAG, `Failed to handle network change: ${JSON.stringify(err)}`);
    }
  }

  /**
   * å¤„ç†ç½‘ç»œä¸å¯ç”¨
   */
  private handleNetworkUnavailable(): void {
    const unavailableInfo: NetworkInfo = {
      netId: 0,
      type: NetworkType.UNKNOWN,
      connectivity: NetworkConnectivity.UNAVAILABLE,
      isMetered: false
    };

    this.currentNetworkInfo = unavailableInfo;
    this.notifyCallbacks(unavailableInfo);
  }

  /**
   * å¤„ç†ç½‘ç»œä¸¢å¤±
   */
  private handleNetworkLost(netHandle: connection.NetHandle): void {
    if (this.currentNetworkInfo?.netId === netHandle.netId) {
      hilog.warn(DOMAIN, TAG, `Current network lost: ${netHandle.netId}`);
      // å°è¯•è·å–æ–°çš„é»˜è®¤ç½‘ç»œ
      this.updateCurrentNetworkInfo();
    }
  }

  /**
   * æ›´æ–°å½“å‰ç½‘ç»œä¿¡æ¯
   */
  private updateCurrentNetworkInfo(): void {
    const info = this.networkService.getDefaultNetworkInfo();
    if (info && this.hasNetworkInfoChanged(info)) {
      hilog.info(DOMAIN, TAG, `Network info updated: ${JSON.stringify(info)}`);
      this.currentNetworkInfo = info;
      this.notifyCallbacks(info);
    }
  }

  /**
   * æ£€æŸ¥ç½‘ç»œä¿¡æ¯æ˜¯å¦æœ‰å˜åŒ–
   */
  private hasNetworkInfoChanged(newInfo: NetworkInfo): boolean {
    if (!this.currentNetworkInfo) {
      return true;
    }

    return this.currentNetworkInfo.netId !== newInfo.netId ||
      this.currentNetworkInfo.type !== newInfo.type ||
      this.currentNetworkInfo.connectivity !== newInfo.connectivity ||
      this.currentNetworkInfo.isMetered !== newInfo.isMetered;
  }

  /**
   * é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…
   */
  private notifyCallbacks(info: NetworkInfo): void {
    this.changeCallbacks.forEach(callback => {
      try {
        callback(info);
      } catch (err) {
        hilog.error(DOMAIN, TAG, `Callback error: ${JSON.stringify(err)}`);
      }
    });
  }

  /**
   * è§£æç½‘ç»œç±»å‹
   */
  private parseNetworkType(bearerTypes?: number[]): NetworkType {
    if (!bearerTypes || bearerTypes.length === 0) {
      return NetworkType.UNKNOWN;
    }

    if (bearerTypes.includes(connection.NetBearType.BEARER_CELLULAR)) {
      return NetworkType.CELLULAR;
    } else if (bearerTypes.includes(connection.NetBearType.BEARER_WIFI)) {
      return NetworkType.WIFI;
    } else if (bearerTypes.includes(connection.NetBearType.BEARER_ETHERNET)) {
      return NetworkType.ETHERNET;
    }

    return NetworkType.UNKNOWN;
  }

  /**
   * è§£æç½‘ç»œè¿é€šæ€§çŠ¶æ€
   */
  private parseConnectivity(networkCap?: number[]): NetworkConnectivity {
    if (!networkCap || networkCap.length === 0) {
      return NetworkConnectivity.UNAVAILABLE;
    }

    if (networkCap.includes(connection.NetCap.NET_CAPABILITY_CHECKING_CONNECTIVITY)) {
      return NetworkConnectivity.CHECKING;
    } else if (networkCap.includes(connection.NetCap.NET_CAPABILITY_VALIDATED)) {
      return NetworkConnectivity.VALIDATED;
    } else {
      return NetworkConnectivity.NOT_VALIDATED;
    }
  }

  /**
   * è·å–ç½‘ç»œçŠ¶æ€æè¿°æ–‡æœ¬
   */
  public static getNetworkStatusText(info: NetworkInfo | null): string {
    if (!info || info.connectivity === NetworkConnectivity.UNAVAILABLE) {
      return 'ç½‘ç»œä¸å¯ç”¨';
    }

    let typeText: string;
    switch (info.type) {
      case NetworkType.WIFI:
        typeText = 'Wi-Fi';
        break;
      case NetworkType.CELLULAR:
        typeText = 'ç§»åŠ¨ç½‘ç»œ';
        break;
      case NetworkType.ETHERNET:
        typeText = 'ä»¥å¤ªç½‘';
        break;
      default:
        typeText = 'æœªçŸ¥ç½‘ç»œ';
        break;
    }

    let connectivityText: string;
    switch (info.connectivity) {
      case NetworkConnectivity.VALIDATED:
        connectivityText = 'å·²è¿æ¥';
        break;
      case NetworkConnectivity.NOT_VALIDATED:
        connectivityText = 'æ— äº’è”ç½‘';
        break;
      case NetworkConnectivity.CHECKING:
        connectivityText = 'æ£€æŸ¥ä¸­';
        break;
      default:
        connectivityText = 'æœªçŸ¥çŠ¶æ€';
        break;
    }

    const meteredText = info.isMetered ? ' (è®¡è´¹)' : '';

    return `${typeText} - ${connectivityText}${meteredText}`;
  }

  /**
   * è·å–ç½‘ç»œå›¾æ ‡
   */
  public static getNetworkIcon(info: NetworkInfo | null): string {
    if (!info || info.connectivity === NetworkConnectivity.UNAVAILABLE) {
      return 'ğŸ“µ'; // æ— ç½‘ç»œ
    }

    if (info.connectivity === NetworkConnectivity.CHECKING) {
      return 'ğŸ”„'; // æ£€æŸ¥ä¸­
    }

    if (info.connectivity === NetworkConnectivity.NOT_VALIDATED) {
      return 'âš ï¸'; // æ— äº’è”ç½‘
    }

    // VALIDATED
    if (info.type === NetworkType.WIFI) {
      return 'ğŸ“¶';
    } else if (info.type === NetworkType.CELLULAR) {
      return 'ğŸ“±';
    } else if (info.type === NetworkType.ETHERNET) {
      return 'ğŸ”Œ';
    } else {
      return 'ğŸŒ';
    }
  }
}
