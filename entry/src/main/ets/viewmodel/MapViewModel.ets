/**
 * åœ°å›¾é¡µé¢ViewModel - ç®¡ç†åœ°å›¾ç›¸å…³çš„ä¸šåŠ¡é€»è¾‘
 * è´Ÿè´£åœ°å›¾æ•°æ®ç®¡ç†ã€æ ‡è®°æ“ä½œã€åœ°å€æ”¶è—ã€åŠ¨ç”»çŠ¶æ€æ§åˆ¶
 */
import { map, mapCommon } from '@kit.MapKit';
import { AsyncCallback } from '@kit.BasicServicesKit';
import { LocationInfo, MapMarker, CollectItem } from '../model/LocationModel';
import { LocationService } from '../utils/LocationUtils';
import { AnimationUtils } from '../utils/AnimationUtils';

const ANNOTATION_POSITION_TOP = 2;
type MarkerSelectionListener = (markerId: string | null, marker?: MapMarker) => void;

export class MapViewModel {
  // åœ°å›¾æ•°æ®çŠ¶æ€
  markers: MapMarker[] = [];
  favoriteLocations: CollectItem[] = [];
  currentLocation: LocationInfo | null = null;
  
  // UIçŠ¶æ€
  isLoading: boolean = false;
  locationPermissionGranted: boolean = false;
  showLocationBubble: boolean = false;
  isAnimating: boolean = false;
  
  // åœ°å€è¾“å…¥çŠ¶æ€
  departureAddress: string = '';
  destinationAddress: string = '';
  
  // MapKit çŠ¶æ€
  mapOptions: mapCommon.MapOptions = {
    position: {
      target: {
        latitude: 22.5431,
        longitude: 114.0579
      },
      zoom: 14
    }
  };
  mapCallback: AsyncCallback<map.MapComponentController> = async (err, controller) => {
    if (err) {
      console.error('åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', JSON.stringify(err));
      return;
    }
    this.mapController = controller;
    this.mapController.setZoomControlsEnabled(false);
    this.mapController.setMyLocationEnabled(false);
    this.mapController.setMyLocationControlsEnabled(false);
    this.mapEventManager = this.mapController.getEventManager();
    this.mapEventManager.on('markerClick', this.handleMarkerClick);
    await this.renderMarkersOnMap();
    if (this.selectedMarkerId) {
      await this.focusMarker(this.selectedMarkerId);
    }
  };
  selectedMarkerId: string | null = null;

  private mapController?: map.MapComponentController;
  private mapEventManager?: map.MapEventManager;
  private markerEntities: Map<string, map.Marker> = new Map();
  private markerSelectionListener?: MarkerSelectionListener;

  private locationService: LocationService = LocationService.getInstance();

  /**
   * åˆå§‹åŒ–åœ°å›¾æ•°æ®
   */
  async initialize(): Promise<void> {
    this.loadMockMarkers();
    this.loadFavoriteLocations();
    this.updateMapCenterFromMarkers();
    await this.checkLocationPermission();
    await this.renderMarkersOnMap();
  }

  setMarkerSelectionListener(listener?: MarkerSelectionListener): void {
    this.markerSelectionListener = listener;
  }

  private notifyMarkerSelection(markerId: string | null, markerData?: MapMarker): void {
    if (this.markerSelectionListener) {
      this.markerSelectionListener(markerId, markerData);
    }
  }

  getMarkerById(id: string | null | undefined): MapMarker | undefined {
    if (!id) {
      return undefined;
    }
    return this.markers.find(marker => marker.id === id);
  }

  /**
   * æ£€æŸ¥å®šä½æƒé™
   */
  async checkLocationPermission(): Promise<void> {
    try {
      const permission = await this.locationService.checkLocationPermission();
      this.locationPermissionGranted = permission === 'granted';
      
      if (!this.locationPermissionGranted) {
        this.showLocationBubble = true;
      } else {
        await this.getCurrentLocation();
      }
    } catch (error) {
      console.error('æ£€æŸ¥å®šä½æƒé™å¤±è´¥:', error);
      this.showLocationBubble = true;
    }
  }

  /**
   * è¯·æ±‚å®šä½æƒé™
   */
  async requestLocationPermission(): Promise<boolean> {
    try {
      const success = await this.locationService.requestLocationPermission();
      if (success) {
        this.locationPermissionGranted = true;
        this.showLocationBubble = false;
        await this.getCurrentLocation();
        return true;
      }
      return false;
    } catch (error) {
      console.error('è¯·æ±‚å®šä½æƒé™å¤±è´¥:', error);
      return false;
    }
  }

  private updateMapCenterFromMarkers(): void {
    if (this.markers.length === 0) {
      return;
    }
    const firstMarker = this.markers[0];
    this.mapOptions.position = {
      target: {
        latitude: firstMarker.latitude,
        longitude: firstMarker.longitude
      },
      zoom: this.mapOptions.position?.zoom ?? 14
    };
  }

  /**
   * è·å–å½“å‰ä½ç½®
   */
  async getCurrentLocation(): Promise<LocationInfo | null> {
    this.isLoading = true;
    try {
      this.currentLocation = await this.locationService.getCurrentLocation();
      if (this.currentLocation) {
        this.animateCameraTo({
          latitude: this.currentLocation.latitude,
          longitude: this.currentLocation.longitude
        }, 15);
      }
      return this.currentLocation;
    } catch (error) {
      console.error('è·å–ä½ç½®å¤±è´¥:', error);
      return null;
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * åŠ è½½æ¨¡æ‹Ÿæ ‡è®°ç‚¹æ•°æ®
   */
  loadMockMarkers(): void {
    this.markers = [
      {
        id: '1',
        latitude: 22.5431,
        longitude: 114.0579,
        title: 'ä¸–ç•Œä¹‹çª—',
        description: 'æ·±åœ³è‘—åä¸»é¢˜å…¬å›­',
        isFavorite: false,
        addTime: '2025-01-15',
        icon: 'ğŸ›ï¸',
        color: '#FF6B35'
      } as MapMarker,
      {
        id: '2',
        latitude: 22.5231,
        longitude: 114.0379,
        title: 'æ¬¢ä¹è°·',
        description: 'æ·±åœ³å¤§å‹ä¸»é¢˜ä¹å›­',
        isFavorite: true,
        addTime: '2025-01-14',
        icon: 'ğŸ¢',
        color: '#4ECDC4'
      } as MapMarker,
      {
        id: '3',
        latitude: 22.5631,
        longitude: 114.0779,
        title: 'ä¸œéƒ¨åä¾¨åŸ',
        description: 'ç”Ÿæ€æ—…æ¸¸åº¦å‡åŒº',
        isFavorite: false,
        addTime: '2025-01-13',
        icon: 'ğŸï¸',
        color: '#45B7D1'
      } as MapMarker,
      {
        id: '4',
        latitude: 22.5031,
        longitude: 114.0179,
        title: 'å¤§æ¢…æ²™æµ·æ»¨å…¬å›­',
        description: 'æµ·æ»¨ä¼‘é—²åº¦å‡åŒº',
        isFavorite: true,
        addTime: '2025-01-12',
        icon: 'ğŸ–ï¸',
        color: '#96CEB4'
      } as MapMarker
    ];
    this.updateMapCenterFromMarkers();
    void this.renderMarkersOnMap();
  }

  /**
   * åŠ è½½æ”¶è—ä½ç½®åˆ—è¡¨
   */
  loadFavoriteLocations(): void {
    this.favoriteLocations = [
      {
        id: '1',
        latitude: 22.5431,
        longitude: 114.0579,
        title: 'ä¸–ç•Œä¹‹çª—',
        description: 'æ·±åœ³å¸‚å—å±±åŒºæ·±å—å¤§é“9037å·',
        addTime: '2025-01-15',
        icon: 'ğŸ›ï¸',
        color: '#FF6B35'
      } as CollectItem,
      {
        id: '2',
        latitude: 22.5231,
        longitude: 114.0379,
        title: 'æ¬¢ä¹è°·',
        description: 'æ·±åœ³å¸‚å—å±±åŒºåä¾¨åŸ',
        addTime: '2025-01-14',
        icon: 'ğŸ¢',
        color: '#4ECDC4'
      } as CollectItem
    ];
  }

  async renderMarkersOnMap(): Promise<void> {
    if (!this.mapController) {
      return;
    }

    const markerIds = new Set(this.markers.map(marker => marker.id));
    for (const entry of this.markerEntities) {
      const id = entry[0];
      const entity = entry[1];
      if (!markerIds.has(id)) {
        entity.remove();
        this.markerEntities.delete(id);
      }
    }

    for (const markerData of this.markers) {
      let markerEntity = this.markerEntities.get(markerData.id);
      if (!markerEntity) {
        const markerOptions: mapCommon.MarkerOptions = {
          position: {
            latitude: markerData.latitude,
            longitude: markerData.longitude
          },
          visible: true,
          alpha: 1,
          anchorU: 0.5,
          anchorV: 1,
          draggable: false,
          clickable: true,
          flat: false,
          zIndex: markerData.isFavorite ? 2 : 1,
          annotations: [{
            content: markerData.title,
            fontSize: 12,
            fontStyle: 1,
            strokeWidth: 3
          }],
          annotationPosition: ANNOTATION_POSITION_TOP
        };
        markerEntity = await this.mapController.addMarker(markerOptions);
        if (!markerEntity) {
          continue;
        }
        markerEntity.setTitle(markerData.id);
        markerEntity.setInfoWindowAnchor(0.5, 1);
        markerEntity.setClickable(true);
        this.markerEntities.set(markerData.id, markerEntity);
      } else {
        markerEntity.setPosition({
          latitude: markerData.latitude,
          longitude: markerData.longitude
        });
      }
      markerEntity.setInfoWindowVisible(this.selectedMarkerId === markerData.id);
    }
  }

  private handleMarkerClick = (marker: map.Marker) => {
    const markerId = marker.getTitle();
    const resolvedId = markerId ?? null;
    this.selectedMarkerId = resolvedId;
    this.updateMarkerInfoWindowVisibility(resolvedId);
    if (resolvedId) {
      marker.setInfoWindowVisible(true);
      this.animateCameraTo(marker.getPosition(), 16);
    }
    const markerData = this.getMarkerById(resolvedId);
    this.notifyMarkerSelection(resolvedId, markerData);
  };

  private updateMarkerInfoWindowVisibility(activeId: string | null): void {
    this.markerEntities.forEach((entity, id) => {
      entity.setInfoWindowVisible(activeId !== null && id === activeId);
    });
  }

  private animateCameraTo(position: mapCommon.LatLng, zoom: number = 15): void {
    if (!this.mapController) {
      return;
    }
    const cameraPosition: mapCommon.CameraPosition = {
      target: position,
      zoom: zoom
    };
    const cameraUpdate: map.CameraUpdate = map.newCameraPosition(cameraPosition);
    this.mapController.animateCamera(cameraUpdate, 500);
  }

  async focusMarker(markerId: string): Promise<void> {
    const markerData = this.getMarkerById(markerId);
    this.selectedMarkerId = markerId;

    if (!this.mapController) {
      this.notifyMarkerSelection(markerId, markerData);
      return;
    }

    this.updateMarkerInfoWindowVisibility(markerId);
    const markerEntity = this.markerEntities.get(markerId);
    if (markerEntity) {
      markerEntity.setInfoWindowVisible(true);
      this.animateCameraTo(markerEntity.getPosition(), 16);
    } else if (markerData) {
      this.animateCameraTo({
        latitude: markerData.latitude,
        longitude: markerData.longitude
      }, 16);
    }
    this.notifyMarkerSelection(markerId, markerData);
  }
 
  /**
   * åˆ‡æ¢æ”¶è—çŠ¶æ€
   */
  toggleFavorite(markerId: string): void {
    const marker = this.markers.find(m => m.id === markerId);
    if (marker) {
      marker.isFavorite = !marker.isFavorite;
      
      // åŒæ­¥æ›´æ–°æ”¶è—åˆ—è¡¨
      if (marker.isFavorite) {
        this.addToFavorites(marker);
      } else {
        this.removeFromFavorites(markerId);
      }
      void this.renderMarkersOnMap();
    }
  }

  /**
   * æ·»åŠ åˆ°æ”¶è—åˆ—è¡¨
   */
  private addToFavorites(marker: MapMarker): void {
    const exists = this.favoriteLocations.find(item => item.id === marker.id);
    if (!exists) {
      const collectItem: CollectItem = {
        id: marker.id,
        latitude: marker.latitude,
        longitude: marker.longitude,
        title: marker.title,
        description: marker.description,
        addTime: new Date().toISOString().split('T')[0],
        icon: marker.icon,
        color: marker.color
      };
      this.favoriteLocations.push(collectItem);
    }
  }

  /**
   * ä»æ”¶è—åˆ—è¡¨ç§»é™¤
   */
  private removeFromFavorites(markerId: string): void {
    const index = this.favoriteLocations.findIndex(item => item.id === markerId);
    if (index !== -1) {
      this.favoriteLocations.splice(index, 1);
    }
  }

  /**
   * æ·»åŠ æ–°æ ‡è®°
   */
  async addMarker(): Promise<MapMarker | null> {
    if (!this.currentLocation) {
      return null;
    }
    
    const newMarker: MapMarker = {
      id: Date.now().toString(),
      latitude: this.currentLocation.latitude + (Math.random() - 0.5) * 0.01,
      longitude: this.currentLocation.longitude + (Math.random() - 0.5) * 0.01,
      title: `æ ‡è®°ç‚¹ ${this.markers.length + 1}`,
      description: 'ç”¨æˆ·æ·»åŠ çš„æ ‡è®°ç‚¹',
      isFavorite: false,
      addTime: new Date().toISOString().split('T')[0],
      icon: 'ğŸ“',
      color: '#64748b'
    };
    
    this.markers.push(newMarker);
    this.updateMapCenterFromMarkers();
    await this.renderMarkersOnMap();
    await this.focusMarker(newMarker.id);
    return newMarker;
  }

  /**
   * åœ°å€äº¤æ¢åŠ¨ç”»
   */
  async swapAddresses(uiContext: UIContext): Promise<void> {
    if (this.isAnimating) return;
    
    this.isAnimating = true;
    
    try {
      // ä½¿ç”¨AnimationUtilså®ç°åœ°å€äº¤æ¢åŠ¨ç”»
      await AnimationUtils.swapAddresses(
        uiContext,
        { text: this.departureAddress },
        { text: this.destinationAddress },
        500
      );
      
      // äº¤æ¢åœ°å€
      const temp = this.departureAddress;
      this.departureAddress = this.destinationAddress;
      this.destinationAddress = temp;
    } finally {
      this.isAnimating = false;
    }
  }

  /**
   * è®¾ç½®å‡ºå‘åœ°
   */
  setDepartureAddress(address: string): void {
    this.departureAddress = address;
  }

  /**
   * è®¾ç½®ç›®çš„åœ°
   */
  setDestinationAddress(address: string): void {
    this.destinationAddress = address;
  }

  /**
   * éšè—ä½ç½®æ°”æ³¡
   */
  hideLocationBubble(): void {
    this.showLocationBubble = false;
  }

  /**
   * æ˜¾ç¤ºä½ç½®æ°”æ³¡
   */
  showLocationBubbleDialog(): void {
    this.showLocationBubble = true;
  }
}

