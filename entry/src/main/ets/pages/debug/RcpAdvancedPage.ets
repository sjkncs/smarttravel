import { rcp } from '@kit.RemoteCommunicationKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { hilog } from '@kit.PerformanceAnalysisKit';
import { TopNavigationBar } from '../../components/TopNavigationBar';
import { ErrorHandler } from '../../utils/ErrorHandler';
import { SmartTravelRcpApi, UserInfo } from '../../api/SmartTravelRcpApi';

const TAG = 'RcpAdvancedPage';
const DOMAIN = 0xFF00;

/**
 * RCP é«˜çº§åŠŸèƒ½æ¼”ç¤ºé¡µé¢
 * 
 * æ¼”ç¤ºåŠŸèƒ½ï¼š
 * 1. è‡ªå®šä¹‰ DNS æœåŠ¡å™¨
 * 2. é™æ€ DNS è§„åˆ™
 * 3. DNS over HTTPS
 * 4. æ‹¦æˆªå™¨ä½¿ç”¨ï¼ˆç¼“å­˜ã€æ—¥å¿—ã€è®¤è¯ï¼‰
 * 5. è¯·æ±‚è¿½è¸ª
 * 6. PATCH è¯·æ±‚
 * 7. å¤šè¡¨å•æäº¤
 */
@Entry
@Component
export struct RcpAdvancedPage {
  @State responseText: string = '';
  @State isLoading: boolean = false;
  @State cacheSize: number = 0;
  @State selectedTab: number = 0;

  private api: SmartTravelRcpApi = SmartTravelRcpApi.getInstance();

  aboutToAppear() {
    this.updateCacheSize();
  }

  private updateCacheSize(): void {
    this.cacheSize = this.api.getCacheSize();
  }

  // ==================== DNS é…ç½®ç¤ºä¾‹ ====================

  /**
   * ç¤ºä¾‹1: è‡ªå®šä¹‰ DNS æœåŠ¡å™¨
   */
  private async testCustomDNS(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯•è‡ªå®šä¹‰ DNS æœåŠ¡å™¨...\n\n';

    try {
      // é…ç½®è‡ªå®šä¹‰ DNS æœåŠ¡å™¨
      const customDnsServers: rcp.DnsServers = [
        { ip: '8.8.8.8' },      // Google DNS
        { ip: '8.8.4.4', port: 53 }
      ];

      const sessionWithCustomDns = rcp.createSession({
        requestConfiguration: {
          dns: {
            dnsRules: customDnsServers
          },
          security: {
            tlsOptions: {
              tlsVersion: 'TlsV1.3'
            }
          }
        }
      });

      this.responseText += 'âœ… DNS æœåŠ¡å™¨é…ç½®ï¼š\n';
      this.responseText += '  - 8.8.8.8 (Google DNS)\n';
      this.responseText += '  - 8.8.4.4:53\n\n';

      const response = await sessionWithCustomDns.get('http://www.example.com');
      this.responseText += `âœ… è¯·æ±‚æˆåŠŸ\nçŠ¶æ€ç : ${response.statusCode}\n`;

      hilog.info(DOMAIN, TAG, 'Custom DNS test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `Custom DNS test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * ç¤ºä¾‹2: é™æ€ DNS è§„åˆ™
   */
  private async testStaticDNS(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯•é™æ€ DNS è§„åˆ™...\n\n';

    try {
      // é…ç½®é™æ€ DNS è§„åˆ™
      const staticDnsRules: rcp.StaticDnsRules = [
        {
          host: 'example.com',
          port: 80,
          ipAddresses: ['192.168.1.1', '192.168.1.2']
        }
      ];

      const sessionWithStaticDns = rcp.createSession({
        requestConfiguration: {
          dns: {
            dnsRules: staticDnsRules
          },
          security: {
            tlsOptions: {
              tlsVersion: 'TlsV1.3'
            }
          }
        }
      });

      this.responseText += 'âœ… é™æ€ DNS è§„åˆ™é…ç½®ï¼š\n';
      this.responseText += '  - Host: example.com:80\n';
      this.responseText += '  - IP: 192.168.1.1, 192.168.1.2\n\n';

      const response = await sessionWithStaticDns.get('http://example.com');
      this.responseText += `âœ… è¯·æ±‚æˆåŠŸ\nçŠ¶æ€ç : ${response.statusCode}\n`;

      hilog.info(DOMAIN, TAG, 'Static DNS test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `Static DNS test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * ç¤ºä¾‹3: DNS over HTTPS
   */
  private async testDNSOverHTTPS(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯• DNS over HTTPS...\n\n';

    try {
      // é…ç½® DNS over HTTPS
      const dohConfig: rcp.DnsOverHttpsConfiguration = {
        url: 'https://dns.example.com/dns-query',
        skipCertificatesValidation: true
      };

      const sessionWithDoh = rcp.createSession({
        requestConfiguration: {
          dns: {
            dnsOverHttps: dohConfig
          },
          security: {
            tlsOptions: {
              tlsVersion: 'TlsV1.3'
            }
          }
        }
      });

      this.responseText += 'âœ… DNS over HTTPS é…ç½®ï¼š\n';
      this.responseText += '  - URL: https://dns.example.com/dns-query\n';
      this.responseText += '  - è·³è¿‡è¯ä¹¦éªŒè¯: æ˜¯\n\n';

      const response = await sessionWithDoh.get('http://www.example.com');
      this.responseText += `âœ… è¯·æ±‚æˆåŠŸ\nçŠ¶æ€ç : ${response.statusCode}\n`;

      hilog.info(DOMAIN, TAG, 'DNS over HTTPS test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `DNS over HTTPS test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  // ==================== æ‹¦æˆªå™¨ç¤ºä¾‹ ====================

  /**
   * ç¤ºä¾‹4: æµ‹è¯•ç¼“å­˜æ‹¦æˆªå™¨
   */
  private async testCacheInterceptor(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯•ç¼“å­˜æ‹¦æˆªå™¨...\n\n';

    try {
      // ç¬¬ä¸€æ¬¡è¯·æ±‚
      this.responseText += 'ğŸ“¡ ç¬¬ä¸€æ¬¡è¯·æ±‚ï¼ˆæ— ç¼“å­˜ï¼‰...\n';
      const startTime1 = Date.now();
      await this.api.getGuideList(1, 10);
      const duration1 = Date.now() - startTime1;
      this.responseText += `âœ… è¯·æ±‚å®Œæˆï¼Œè€—æ—¶: ${duration1}ms\n\n`;

      // ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼‰
      this.responseText += 'ğŸ“¡ ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆåº”å‘½ä¸­ç¼“å­˜ï¼‰...\n';
      const startTime2 = Date.now();
      await this.api.getGuideList(1, 10);
      const duration2 = Date.now() - startTime2;
      this.responseText += `âœ… è¯·æ±‚å®Œæˆï¼Œè€—æ—¶: ${duration2}ms\n\n`;

      if (duration2 < duration1) {
        this.responseText += `ğŸš€ ç¼“å­˜ç”Ÿæ•ˆï¼é€Ÿåº¦æå‡: ${((duration1 - duration2) / duration1 * 100).toFixed(1)}%\n`;
      }

      this.updateCacheSize();
      this.responseText += `\nğŸ“¦ ç¼“å­˜å¤§å°: ${this.cacheSize} é¡¹\n`;

      hilog.info(DOMAIN, TAG, 'Cache interceptor test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `Cache test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  /**
   * ç¤ºä¾‹5: æ¸…é™¤ç¼“å­˜
   */
  private clearCache(): void {
    this.api.clearCache();
    this.updateCacheSize();
    this.responseText = `âœ… ç¼“å­˜å·²æ¸…é™¤\n\nğŸ“¦ å½“å‰ç¼“å­˜å¤§å°: ${this.cacheSize} é¡¹\n`;
    ErrorHandler.showToast('ç¼“å­˜å·²æ¸…é™¤');
  }

  // ==================== PATCH è¯·æ±‚ç¤ºä¾‹ ====================

  /**
   * ç¤ºä¾‹6: PATCH è¯·æ±‚ï¼ˆéƒ¨åˆ†æ›´æ–°ï¼‰
   */
  private async testPatchRequest(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯• PATCH è¯·æ±‚ï¼ˆéƒ¨åˆ†æ›´æ–°ï¼‰...\n\n';

    try {
      const userId = 'user_001';

      // åªæ›´æ–°ç”¨æˆ·åï¼Œä¸å½±å“å…¶ä»–å­—æ®µ
      this.responseText += 'ğŸ“ æ›´æ–°ç”¨æˆ·ä¿¡æ¯ï¼ˆåªæ›´æ–° userNameï¼‰...\n';
      const updates: Partial<UserInfo> = {
        userName: 'å¼ ä¸‰ï¼ˆå·²æ›´æ–°ï¼‰'
      };

      const updatedUser = await this.api.updateUserInfo(userId, updates);

      this.responseText += 'âœ… æ›´æ–°æˆåŠŸ\n\n';
      this.responseText += 'æ›´æ–°åçš„ä¿¡æ¯ï¼š\n';
      this.responseText += `  - ç”¨æˆ·ID: ${updatedUser.userId}\n`;
      this.responseText += `  - ç”¨æˆ·å: ${updatedUser.userName}\n`;
      this.responseText += `  - æ€§åˆ«: ${updatedUser.userGender}\n`;
      this.responseText += `  - å¹´é¾„: ${updatedUser.userAge}\n\n`;
      this.responseText += 'ğŸ’¡ PATCH åªæ›´æ–°æŒ‡å®šå­—æ®µï¼Œå…¶ä»–å­—æ®µä¿æŒä¸å˜\n';

      hilog.info(DOMAIN, TAG, 'PATCH request test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `PATCH test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  // ==================== å¤šè¡¨å•æäº¤ç¤ºä¾‹ ====================

  /**
   * ç¤ºä¾‹7: å¤šè¡¨å•æäº¤
   */
  private async testMultipartForm(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯•å¤šè¡¨å•æäº¤...\n\n';

    try {
      this.responseText += 'ğŸ“‹ æäº¤é…’åº—é¢„è®¢è¡¨å•...\n\n';

      const result = await this.api.createHotelBooking({
        hotelId: 'hotel_001',
        roomType: 'è±ªåå¤§åºŠæˆ¿',
        checkInDate: '2024-12-01',
        checkOutDate: '2024-12-03',
        guestName: 'å¼ ä¸‰',
        guestPhone: '13800138000',
        specialRequests: 'éœ€è¦æ— çƒŸæˆ¿é—´'
      });

      this.responseText += 'âœ… é¢„è®¢æˆåŠŸ\n\n';
      this.responseText += 'è®¢å•ä¿¡æ¯ï¼š\n';
      this.responseText += `  - è®¢å•ID: ${result.orderId}\n`;
      this.responseText += `  - è®¢å•å·: ${result.orderNo}\n\n`;
      this.responseText += 'ğŸ’¡ ä½¿ç”¨ MultipartForm æäº¤å¤šä¸ªè¡¨å•å­—æ®µ\n';

      hilog.info(DOMAIN, TAG, 'Multipart form test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `âŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `Multipart form test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  // ==================== è¯·æ±‚è¿½è¸ªç¤ºä¾‹ ====================

  /**
   * ç¤ºä¾‹8: è¯·æ±‚è¯¦ç»†è¿½è¸ª
   */
  private async testRequestTracing(): Promise<void> {
    this.isLoading = true;
    this.responseText = 'æµ‹è¯•è¯·æ±‚è¯¦ç»†è¿½è¸ª...\n\n';

    try {
      // é…ç½®è¿½è¸ª
      const customHttpEventsHandler: rcp.HttpEventsHandler = {
        onDataReceive: (incomingData: ArrayBuffer) => {
          this.responseText += `ğŸ“¥ æ¥æ”¶æ•°æ®: ${incomingData.byteLength} å­—èŠ‚\n`;
          return incomingData.byteLength;
        },
        onHeaderReceive: (headers: rcp.RequestHeaders) => {
          this.responseText += `ğŸ“‹ æ¥æ”¶å“åº”å¤´\n`;
        },
        onDataEnd: () => {
          this.responseText += `âœ… æ•°æ®ä¼ è¾“å®Œæˆ\n`;
        }
      };

      const tracingConfig: rcp.TracingConfiguration = {
        verbose: true,
        infoToCollect: {
          incomingHeader: true,
          outgoingHeader: true,
          incomingData: true,
          outgoingData: true
        },
        collectTimeInfo: true,
        httpEventsHandler: customHttpEventsHandler
      };

      const sessionWithTracing = rcp.createSession({
        requestConfiguration: {
          tracing: tracingConfig,
          security: {
            tlsOptions: {
              tlsVersion: 'TlsV1.3'
            }
          }
        }
      });

      this.responseText += 'ğŸ” å¼€å§‹è¿½è¸ªè¯·æ±‚...\n\n';

      const response = await sessionWithTracing.get('http://developer.huawei.com');

      this.responseText += `\nğŸ“Š è¯·æ±‚ç»Ÿè®¡ï¼š\n`;
      this.responseText += `  - çŠ¶æ€ç : ${response.statusCode}\n`;
      if (response.timeInfo) {
        this.responseText += `  - DNS è§£æ: ${response.timeInfo.dnsLookupTime}ms\n`;
        this.responseText += `  - è¿æ¥å»ºç«‹: ${response.timeInfo.tcpConnectionTime}ms\n`;
        this.responseText += `  - SSL æ¡æ‰‹: ${response.timeInfo.tlsConnectionTime}ms\n`;
        this.responseText += `  - æ€»æ—¶é—´: ${response.timeInfo.totalTime}ms\n`;
      }

      hilog.info(DOMAIN, TAG, 'Request tracing test succeeded');
    } catch (error) {
      const err = error as BusinessError;
      this.responseText += `\nâŒ å¤±è´¥: ${err.message}\n`;
      hilog.error(DOMAIN, TAG, `Tracing test failed: ${JSON.stringify(error)}`);
    } finally {
      this.isLoading = false;
    }
  }

  build() {
    Column() {
      TopNavigationBar({
        title: 'RCP é«˜çº§åŠŸèƒ½',
        showBack: true
      })

      // æ ‡ç­¾é¡µ
      Tabs({ index: this.selectedTab }) {
        // DNS é…ç½®
        TabContent() {
          this.DnsConfigTab()
        }.tabBar('DNS é…ç½®')

        // æ‹¦æˆªå™¨
        TabContent() {
          this.InterceptorsTab()
        }.tabBar('æ‹¦æˆªå™¨')

        // é«˜çº§è¯·æ±‚
        TabContent() {
          this.AdvancedRequestsTab()
        }.tabBar('é«˜çº§è¯·æ±‚')

        // è¿½è¸ª
        TabContent() {
          this.TracingTab()
        }.tabBar('è¿½è¸ª')
      }
      .onChange((index: number) => {
        this.selectedTab = index;
      })
    }
    .width('100%')
    .height('100%')
    .backgroundColor('#f5f5f5')
  }

  @Builder
  DnsConfigTab() {
    Scroll() {
      Column({ space: 12 }) {
        Text('DNS é…ç½®ç¤ºä¾‹')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .margin({ top: 16, bottom: 8 })

        Button('æµ‹è¯•è‡ªå®šä¹‰ DNS æœåŠ¡å™¨')
          .width('100%')
          .onClick(() => this.testCustomDNS())
          .enabled(!this.isLoading)

        Button('æµ‹è¯•é™æ€ DNS è§„åˆ™')
          .width('100%')
          .onClick(() => this.testStaticDNS())
          .enabled(!this.isLoading)

        Button('æµ‹è¯• DNS over HTTPS')
          .width('100%')
          .onClick(() => this.testDNSOverHTTPS())
          .enabled(!this.isLoading)

        if (this.responseText) {
          Column() {
            Text('å“åº”ç»“æœï¼š')
              .fontSize(14)
              .fontWeight(FontWeight.Medium)
              .margin({ bottom: 8 })
            Text(this.responseText)
              .fontSize(12)
              .fontColor('#333')
              .fontFamily('monospace')
          }
          .width('100%')
          .padding(12)
          .backgroundColor('#f9f9f9')
          .borderRadius(8)
        }
      }
      .padding(16)
    }
  }

  @Builder
  InterceptorsTab() {
    Scroll() {
      Column({ space: 12 }) {
        Text('æ‹¦æˆªå™¨ç¤ºä¾‹')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .margin({ top: 16, bottom: 8 })

        Row() {
          Text(`ç¼“å­˜å¤§å°: ${this.cacheSize} é¡¹`)
            .fontSize(14)
            .layoutWeight(1)
          Button('æ¸…é™¤ç¼“å­˜')
            .height(36)
            .fontSize(14)
            .onClick(() => this.clearCache())
        }
        .width('100%')
        .padding(12)
        .backgroundColor(Color.White)
        .borderRadius(8)

        Button('æµ‹è¯•ç¼“å­˜æ‹¦æˆªå™¨')
          .width('100%')
          .onClick(() => this.testCacheInterceptor())
          .enabled(!this.isLoading)

        if (this.responseText) {
          Column() {
            Text('å“åº”ç»“æœï¼š')
              .fontSize(14)
              .fontWeight(FontWeight.Medium)
              .margin({ bottom: 8 })
            Text(this.responseText)
              .fontSize(12)
              .fontColor('#333')
              .fontFamily('monospace')
          }
          .width('100%')
          .padding(12)
          .backgroundColor('#f9f9f9')
          .borderRadius(8)
        }
      }
      .padding(16)
    }
  }

  @Builder
  AdvancedRequestsTab() {
    Scroll() {
      Column({ space: 12 }) {
        Text('é«˜çº§è¯·æ±‚ç¤ºä¾‹')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .margin({ top: 16, bottom: 8 })

        Button('æµ‹è¯• PATCH è¯·æ±‚')
          .width('100%')
          .onClick(() => this.testPatchRequest())
          .enabled(!this.isLoading)

        Button('æµ‹è¯•å¤šè¡¨å•æäº¤')
          .width('100%')
          .onClick(() => this.testMultipartForm())
          .enabled(!this.isLoading)

        if (this.responseText) {
          Column() {
            Text('å“åº”ç»“æœï¼š')
              .fontSize(14)
              .fontWeight(FontWeight.Medium)
              .margin({ bottom: 8 })
            Text(this.responseText)
              .fontSize(12)
              .fontColor('#333')
              .fontFamily('monospace')
          }
          .width('100%')
          .padding(12)
          .backgroundColor('#f9f9f9')
          .borderRadius(8)
        }
      }
      .padding(16)
    }
  }

  @Builder
  TracingTab() {
    Scroll() {
      Column({ space: 12 }) {
        Text('è¯·æ±‚è¿½è¸ªç¤ºä¾‹')
          .fontSize(16)
          .fontWeight(FontWeight.Bold)
          .margin({ top: 16, bottom: 8 })

        Button('æµ‹è¯•è¯·æ±‚è¯¦ç»†è¿½è¸ª')
          .width('100%')
          .onClick(() => this.testRequestTracing())
          .enabled(!this.isLoading)

        if (this.responseText) {
          Column() {
            Text('è¿½è¸ªä¿¡æ¯ï¼š')
              .fontSize(14)
              .fontWeight(FontWeight.Medium)
              .margin({ bottom: 8 })
            Text(this.responseText)
              .fontSize(12)
              .fontColor('#333')
              .fontFamily('monospace')
          }
          .width('100%')
          .padding(12)
          .backgroundColor('#f9f9f9')
          .borderRadius(8)
        }
      }
      .padding(16)
    }
  }
}
